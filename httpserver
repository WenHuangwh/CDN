#!/usr/bin/env python3
import http.client
import argparse
import socket
import time
from collections import OrderedDict
from functools import reduce

class LRUCache:
    def __init__(self, capacity):
        self.cache = OrderedDict()
        self.capacity = capacity
    
    def get(self, key):
        if key not in self.cache:
            return None
        value = self.cache.pop(key)
        self.cache[key] = value
        return value
    
    def put(self, key, value):
        if key in self.cache:
            self.cache.pop(key)
        elif len(self.cache) >= self.capacity:
            self.cache.popitem(last=False)
        self.cache[key] = value

def write_log(log_entry):
    with open("log.txt", "a") as log_file:
        log_file.write(log_entry + "\n")

def handle_request(request, origin, cache):
    request_parts = request.split()
    if len(request_parts) < 2:
        return b"HTTP/1.1 400 Bad Request\r\n\r\n"
    
    path = request_parts[1]

    if path == "/grading/beacon":
        return b"HTTP/1.1 204 No Content\r\n\r\n"
    # Have records in cache
    elif (cached_response := cache.get(path)) is not None:
        write_log(f"Getting from cache: {path}")
        return cached_response
    # otherwise retrieve from origin
    # for invalid path, origin will respond with a 404
    else:
        write_log(f"Getting from origin: {path}")
        conn = http.client.HTTPConnection(origin)
        # Start the timer
        start_time = time.time()
        # Add the Host header to the request
        headers = {"Host": origin}
        conn.request("GET", path, headers=headers)
        
        response = conn.getresponse()
        
        # End the timer and calculate the time taken
        end_time = time.time()
        time_taken = end_time - start_time

        response_headers = response.getheaders()
        response_content = response.read()

        response_bytes = bytearray()
        response_line = f"HTTP/1.1 {response.status} {response.reason}\r\n"
        response_bytes.extend(response_line.encode())

        for header, value in response_headers:
            header_line = f"{header}: {value}\r\n"
            response_bytes.extend(header_line.encode())

        response_bytes.extend(b"\r\n")
        response_bytes.extend(response_content)

        # Log the time taken to get the website from the origin server
        write_log(f"Time taken to get {path} from origin: {time_taken:.4f} seconds")
        
        # Cache the response
        cache.put(path, bytes(response_bytes))

        return bytes(response_bytes)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--port', required=True, help="Port number to bind the HTTP server")
    parser.add_argument('-o', '--origin', required=True, help="Origin server for the CDN")
    args = parser.parse_args()

    # Set up the socket for the HTTP server
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.bind(("", int(args.port)))
    sock.listen()

    # Create an instance of the LR