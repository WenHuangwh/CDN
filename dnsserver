#!/usr/bin/env python3
import argparse
import socket
from dnslib import DNSRecord, DNSHeader, QTYPE, A, RR
import subprocess
import logging
import time
import json
import threading

ROOT_SERVICE = "198.41.0.4"
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

class ReplicaManager:
    def __init__(self, replica_servers):
        self.replica_servers = replica_servers
        self.client_replica_map = self.load_map_cache()
        self.update_interval = 600  # 10 minutes in seconds
        self.start_update_thread()

    # Start a thread to regularly update the client to replica map
    def start_update_thread(self):
        update_thread = threading.Thread(target=self.update_map, daemon=True)
        update_thread.start()

    # Update the client to replica map by measuring latency to each replica server
    def update_map(self):
        while True:
            for client_ip in self.client_replica_map:
                latencies = {}
                for server in self.replica_servers:
                    try:
                        latency = self.measure_latency(server, client_ip)
                        latencies[server] = latency
                    except Exception as e:
                        print(f"Error measuring latency for server {server}: {e}")
                        continue

                best_replica = min(latencies, key=latencies.get)
                self.client_replica_map[client_ip] = best_replica
            self.save_map_cache()
            time.sleep(self.update_interval)

    # Load the cached client to replica map from a file
    def load_map_cache(self):
        try:
            with open("map_cache", "r") as f:
                return json.load(f)
        except FileNotFoundError:
            return {}

    # Save the current client to replica map to a file
    def save_map_cache(self):
        with open("map_cache", "w") as f:
            json.dump(self.client_replica_map, f)

    # Measure the latency between the http replica server and the client
    def measure_latency(self, server, client_ip, latency_port = 20022):
        # Connect to the HTTP server's latency measurement port
        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.connect((server, latency_port))
            sock.sendall(client_ip.encode())
            latency = float(sock.recv(1024).decode())
            with open("log.txt", "a") as log_file:
                log_file.write("latency:" + "\n")
                log_file.write(str(latency) + "\n")
            return latency

    # Get the best replica for a client based on the measured latency
    def get_best_replica(self, client_ip):
        if client_ip not in self.client_replica_map:
            latencies = {}
            for server in self.replica_servers:
                try:
                    latency = self.measure_latency(server, client_ip)
                    latencies[server] = latency
                except Exception as e:
                    print(f"Error measuring latency for server {server}: {e}")
                    continue

            best_replica = min(latencies, key=latencies.get)
            self.client_replica_map[client_ip] = best_replica
            self.save_map_cache()
            with open("log.txt", "a") as log_file:
                log_file.write("Test map:" + "\n")
                log_file.write(client_ip + "\n")
                log_file.write(self.client_replica_map[client_ip] + "\n")

        return self.client_replica_map[client_ip]


class DNSServer:
    def __init__(self, port, cdn_name, replica_manager):
        self.port = port
        self.cdn_name = cdn_name
        self.replica_manager = replica_manager
        self.sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        self.sock.bind(("", self.port))

    # Handle incoming DNS queries, returning the best replica IP 
    # based on latency for CDN-specific queries
    def handle_query(self, query, client_addr):
        response = query.reply()
        qtype = QTYPE[query.q.qtype]
        query_name = str(query.q.qname).rstrip('.')
        
        if qtype == "A" and query_name.startswith(self.cdn_name):
            client_ip = client_addr[0]
            best_replica = self.replica_manager.get_best_replica(client_ip)
            best_replica_ip = socket.gethostbyname(best_replica)
            answer = RR(query.q.qname, QTYPE.A, rdata=A(best_replica_ip), ttl=3600)
        else:
            answer = RR(query.q.qname, QTYPE.A, rdata=A(ROOT_SERVICE), ttl=3600)

        response.add_answer(answer)
        return response

    # Main loop for the DNS server, continuously receiving and handling DNS queries
    def run(self):
        while True:
            data, addr = self.sock.recvfrom(1024)
            query = DNSRecord.parse(data)
            response = self.handle_query(query, addr)
            self.sock.sendto(response.pack(), addr)

def main():
    parser = argparse.ArgumentParser()
    parser.add_argument('-p', '--port', required=True, help="Port number to bind the DNS server")
    parser.add_argument('-n', '--name', required=True, help="CDN-specific name that your server translates to an IP")
    args = parser.parse_args()

    port = int(args.port)
    cdn_name = args.name

    replica_servers = [
        "cdn-http1.5700.network",
        "cdn-http2.5700.network",
        "cdn-http3.5700.network",
        "cdn-http4.5700.network",
        "cdn-http5.5700.network",
        "cdn-http6.5700.network",
        "cdn-http7.5700.network",
    ]

    try:
        replica_manager = ReplicaManager(replica_servers)
        dns_server = DNSServer(port, cdn_name, replica_manager)
        logging.info(f"Starting DNS server on port {port}")
        dns_server.run()
    except Exception as e:
        logging.error(f"Error occurred: {e}")
if __name__ == "__main__":
    main()